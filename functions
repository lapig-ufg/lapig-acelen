//Import dataset
var data = require('users/Amazonas21/acelen:datasets')

//Dictionary containing spectral indexes and their formulas
var indexes = {
    'CAI': "(b('B12') / b('B11'))", //Cellulose absorption index
    'NDVI': "(b('B8') - b('B4')) / (b('B8') + b('B4'))", //Normalized Difference Vegetation Index
    'NDWI': "(b('B8') - b('B11')) / (b('B8') + b('B11'))", //Normalized Difference Water/Wetness Index
    'CRI1': "1/(b('B2')) - 1/(b('B3'))", //Carotenoid Reflectance Index 1
    'ARI_1': "(1/b('B3') - 1/b('B5'))*1000", //Anthocyanin Reflectance Index 1
    'RGR': "b('B4')/b('B3')", //Simple Ratio Red/Green Red-Green Ratio
    'PSRI': "(b('B4') - b('B2') )/(b('B6'))", //Plant Senescence Reflectance Index
    'SATVI': "((b('B11') - b('B4'))/(b('B11') + b('B4') + 0.5))*(1*0.5)-(b('B12')/2)*0.0001" //Soil-Adjusted Total Vegetation Index
}

//List of names to rename amplitude bands
var BandsWetAmp = ['blue_wet_amp', 'green_wet_amp', 'red_wet_amp', 'rededge1_wet_amp',
    'rededge2_wet_amp', 'rededge3_wet_amp', 'nir_wet_amp', 'rededge4_wet_amp', 'swir1_wet_amp', 'swir2_wet_amp',
    'ndvi_wet_amp', 'ndwi_wet_amp', 'cai_wet_amp', 'cri1_wet_amp', 'ari1_wet_amp', 'rgr_wet_amp',
    'psri_wet_amp', 'satvi_wet_amp'
];

//Function made to estimate spectral indexes for each image in the Image Collection
exports.spectralFeatures = function (image) {

    var ndvi = image.expression(indexes["NDVI"]).select([0], ['NDVI']) //Calculates the NDVI
    var ndwi = image.expression(indexes["NDWI"]).select([0], ['NDWI']) //Calculates the NDWI
    var cai = image.expression(indexes["CAI"]).select([0], ['CAI']) //Calculate thes CAI
    var cri1 = image.expression(indexes["CRI1"]).select([0], ['CRI1']) //Calculates the CRI1
    var ari1 = image.expression(indexes["ARI_1"]).select([0], ['ARI_1']) //Calculates the ARI_1
    var rgr = image.expression(indexes["RGR"]).select([0], ['RGR']) //Calculates the RGR
    var psri = image.expression(indexes["PSRI"]).select([0], ['PSRI']) //Calculates the PSRI
    var satvi = image.expression(indexes["SATVI"]).select([0], ['SATVI']) //Calculates the SATVI

    image = image.addBands([ndvi, ndwi, cai, cri1, ari1, rgr, psri, satvi]) //Adds the spectral indexes to the image with the spectral bands

    return image
}

//Function made to reduce all images/band in the collection to their specific reductor, e.g. median.
exports.temporalFeatures = function(image) {

    var min = image.reduce(ee.Reducer.min()) //Reduces all bands to the minimum of their values per pixel
    var max = image.reduce(ee.Reducer.max()) //Reduces all bands to the maximum of their values per pixel
    var median = image.reduce(ee.Reducer.median()) //Reduces all bands to the median of their values per pixel
    var stdv = image.reduce(ee.Reducer.stdDev()) //Reduces all bands to the standaard deviation of their values per pixel

    var amp = (image.reduce(ee.Reducer.max()) //Reduces all bands to the amplitude (max - min) of their values per pixel
        .subtract(image.reduce(ee.Reducer.min()))
        .rename(BandsWetAmp))

    var result = (ee.Image().select()
        .addBands([min, max, median, amp, stdv])) //Creates an empty image and add the reduced bands to it
    return result
}

//Function made to reduce all images/band in the collection to their percentiles, e.g. 10%, 25%, 75% and 90%.
exports.temporalPercs = function(image) {

    var percs = image.reduce(ee.Reducer.percentile([10, 25, 75, 90]))

    var result = ee.Image().select().addBands([percs])

    return result
}

//Function made to generate the latitude and the longitude of each pixel
exports.getLatLong  = function(img){
    // Gets the projection
    var proj = ee.Image(img).select(0).projection() //Gets the reference projection from one image
    var latlon = ee.Image.pixelLonLat() //Estimates the latitude and longitude for each pixel
    return ee.Image(img).addBands(latlon.select('longitude', 'latitude')) //Adds the latitude and the longitude as a band
}

//Function made to mask cloud and shadows in the images, based on the quality band from Google Cloud Score (cs)
exports.maskClouds = function(img) {
    // The threshold for masking; values between 0.50 and 0.65 generally work well.
    // Higher values will remove thin clouds, haze & cirrus shadows.
    var CLEAR_THRESHOLD = 0.50;
    var mask = img.select('cs').gte(CLEAR_THRESHOLD); //Masks the pixels with 50% of chance or more to be clouds.
    return img.updateMask(mask);
}

exports.res_bilinear = function(img) {

    //#Resamples the 20 meters bands to 10m using bilinear resampling method
    var bands = img.select('B5', 'B6', 'B7', 'B8A', 'B11', 'B12'); //Bands to be resampled from 20 to 10 meters

    return img.resample('bilinear').reproject({
        'crs': bands.projection().crs(), //Gets the projection
        'scale': img.select('B8').projection().nominalScale() //Gets the pixel size
    })
}



//Function made to mask some weird black edges which can appear in some Sentinel 2 images
exports.maskEdges = function(s2_img){
    return s2_img.updateMask(
        s2_img.select('B8A').mask().updateMask(s2_img.select('B9').mask())) //Defined
}


//Create thresholds from samples
exports.thresholdSamples = function(img,area,type,year){
  
  //Clip and select image from year
  img = img.select(year+'_probability').clip(area)
  
  //Threshold Values
  var dictype = {
    'cultivated':{
                  'positive':54,
                  'negative':30
    },
    'natural':{
                 'positive':60,
                 'negative':25
    }
    
  }
  //Access threshold type
  var threshold = dictype[type]

  //Access threshold positive and negative
  var pos_samples = img.gte(threshold.positive).selfMask()
                    .rename(type+"_"+year+"_positive")
  
  var neg_samples = img.lte(threshold.negative).selfMask()
                     .remap([1],[0])
                    .rename(type+"_"+year+"_negative")
  
  var target = ee.Image().addBands([pos_samples,neg_samples])
               .reduce(ee.Reducer.firstNonNull())
               .rename('targetMap')
               
  return target
}

exports.automatedSamples = function(img,type,year,area,numSamples,scale){
 
  //Area images
  var cliparea = area.geometry().buffer(10000)

  //Calculation samples        
  var target = exports.thresholdSamples(img,cliparea,type,year)

  //Create points from samples positive and negative from GPW maps
  var samples = target.stratifiedSample({
    numPoints:numSamples,
    classBand: 'targetMap',
    region:cliparea,
    scale:scale,
    geometries: true
  })
  
  return {'target-data':target,'samples':samples}
  
}

exports.calcFeatureImportance = function(classifier){
 //Calculates the feature/variable importance for the classifier
    var importance = ee.Dictionary(classifier.explain().get('importance'))
    
    //Do something to rank/sort the importance of the features from highest to lowest
    var keys = importance.keys().sort(importance.values()).reverse()
    var values = importance.values(keys);

    var rows = keys.zip(values).map(function(list) {
        return {
            c: ee.List(list).map(function(n) {
                return {
                    v: n
                };
            })
        }
    })

    var dataTable = {
        cols: [{
                id: 'band',
                label: 'Band',
                type: 'string'
            },
            {
                id: 'importance',
                label: 'Importance',
                type: 'number'
            }
        ],
        rows: rows
    };
    
    //Prints the ranked feature importance
    return keys.zip(values)
}

exports.trendgpp = function(img,initial,final,areas){
  //Calculation trend over GPP data from GPW
  var trend = img.filterBounds(areas)
              .filterDate(initial,final).map(function(image){
              return image.addBands(image.metadata('system:time_start').divide(1e18));
  }).reduce(ee.Reducer.linearFit()).select('scale')
    
  return trend.clip(areas)
}




