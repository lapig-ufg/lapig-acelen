//Import dataset
var data = require('users/Amazonas21/acelen:datasets')


exports.spectralFeatures = function(image){

    ndvi = image.expression(indexes["NDVI"]).select([0],['NDVI']) //Calculates the NDVI
    ndwi = image.expression(indexes["NDWI"]).select([0],['NDWI']) //Calculates the NDWI
    cai = image.expression(indexes["CAI"]).select([0],['CAI']) //Calculate thes CAI
    cri1 = image.expression(indexes["CRI1"]).select([0],['CRI1']) //Calculates the CRI1
    ari1 = image.expression(indexes["ARI_1"]).select([0],['ARI_1']) //Calculates the ARI_1
    rgr = image.expression(indexes["RGR"]).select([0], ['RGR']) //Calculates the RGR
    psri = image.expression(indexes["PSRI"]).select([0], ['PSRI']) //Calculates the PSRI
    satvi = image.expression(indexes["SATVI"]).select([0], ['SATVI']) //Calculates the SATVI

    image = image.addBands([ndvi, ndwi, cai, cri1, ari1, rgr, psri, satvi]) //Adds the spectral indexes to the image with the spectral bands

    return image
}

exports.temporalFeatures = function(image){

    min = image.reduce(ee.Reducer.min()) //Reduces all bands to the minimum of their values per pixel
    max = image.reduce(ee.Reducer.max()) //Reduces all bands to the maximum of their values per pixel
    median = image.reduce(ee.Reducer.median()) //Reduces all bands to the median of their values per pixel
    stdv = image.reduce(ee.Reducer.stdDev()) //Reduces all bands to the standaard deviation of their values per pixel

    amp = (image.reduce(ee.Reducer.max()) //Reduces all bands to the amplitude (max - min) of their values per pixel
        .subtract(image.reduce(ee.Reducer.min()))
        .rename(BandsWetAmp))

    result = (ee.Image().select()
        .addBands([min, max, median, amp, stdv])) //Creates an empty image and add the reduced bands to it
    return result
}

exports.temporalPercs  = function(image){

    percs = image.reduce(ee.Reducer.percentile([10, 25, 75, 90]))

    result = ee.Image().select().addBands([percs])

    return result
}
//Function made to generate the latitude and the longitude of each pixel
exports.getLatLong  = function(img){
    // Gets the projection
    proj = ee.Image(img).select(0).projection() //Gets the reference projection from one image
    latlon = ee.Image.pixelLonLat() //Estimates the latitude and longitude for each pixel
    return ee.Image(img).addBands(latlon.select('longitude', 'latitude')) //Adds the latitude and the longitude as a band
}
//Function made to mask cloud and shadows in the images, based on the quality band from Google Cloud Score (cs)
exports.maskClouds = function(img){
    // The threshold for masking; values between 0.50 and 0.65 generally work well.
    // Higher values will remove thin clouds, haze & cirrus shadows.
    CLEAR_THRESHOLD = 0.50;
    mask = img.select('cs').gte(CLEAR_THRESHOLD); //Masks the pixels with 50% of chance or more to be clouds.
    return img.updateMask(mask);
}
//Function made to convert deegre image to percent
exports.radians = function(img){
    return img.toFloat().multiply(math.pi).divide(180)
}

exports.res_bilinear = function(img){

    //Resamples the 20 meters bands to 10m using bilinear resampling method
    bands = img.select('B5', 'B6', 'B7', 'B8A', 'B11', 'B12'); //Bands to be resampled from 20 to 10 meters

    //return img.resample('bilinear').reproject(**{
    //    'crs': bands.projection().crs(), #Gets the projection
    //    'scale': img.select('B8').projection().nominalScale() #Gets the pixel size
    //})
}

//Function made to mask some weird black edges which can appear in some Sentinel 2 images
exports.maskEdges = function(s2_img){
    return s2_img.updateMask(
        s2_img.select('B8A').mask().updateMask(s2_img.select('B9').mask())) //Defined
}

//Function made to get the image NDVI and mask it according to the 25% NDVI percentile
exports.onlyWetSeasonNei = function(image){
        seasonMask = image.select("ndvi_wet").gte(wetThresholdNei);
        return image.mask(seasonMask);
}

//Create thresholds from samples
exports.thresholdSamples = function(img,area,type,year){
  
  img = img.select(year+'_probability')
  //Threshold Values
  dictype = {
    'cultivated':{
                  'positive':50,
                  'negative':15
    },
    'natural':{
                 'positive':70,
                 'negative':25
    }
    
  }
  //Access threshold type
  var threshold = dictype[type]

  //Access threshold positive and negative
  var pos_samples = img.updateMask(cultiv_grassland_p.first().gte(threshold.positive))
  var neg_samples = img.updateMask(cultiv_grassland_p.first().lte(threshold.negative))
  
  return [pos_samples,neg_samples]
}
